package tcpserver

import (
	"bytes"
	"crypto/tls"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"time"

	"gopkg.in/gomail.v2"
)

type AlertMsg struct {
	NodeName     string
	NodeIp       string
	Metric       string
	Threshold    string
	CurrentValue string
	Timestamp    time.Time
}

func SendDiscordAlert(webhookURL string, alert AlertMsg) error {
	// Format the alert message
	message := fmt.Sprintf(
		"ðŸš¨ **ALERT** ðŸš¨\nNode: `%s`\nIP: `%s`\nMetric: **%s**\nCurrent Value: `%s`\nThreshold: `%s`\nTimestamp: %s",
		alert.NodeName, alert.NodeIp, alert.Metric, alert.CurrentValue, alert.Threshold, alert.Timestamp.Format(time.RFC1123),
	)

	// Prepare the payload
	payload := map[string]string{
		"content": message,
	}

	// Marshal the payload to JSON
	body, err := json.Marshal(payload)
	if err != nil {
		return err
	}

	// Send the POST request to the Discord webhook
	resp, err := http.Post(webhookURL, "application/json", bytes.NewBuffer(body))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Check for successful response
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		fmt.Println("Alert sent to Discord!")
	} else {
		return fmt.Errorf("failed to send alert, status code: %d", resp.StatusCode)
	}

	return nil
}

// SendEmailAlert sends alert notifications via email
func SendEmailAlert(toEmail string, alert AlertMsg) error {
	// Get email configuration from environment
	host := os.Getenv("MAIL_HOST")
	portStr := os.Getenv("MAIL_PORT")
	username := os.Getenv("MAIL_USERNAME")
	password := os.Getenv("MAIL_PASSWORD")
	fromAddress := os.Getenv("MAIL_FROM_ADDRESS")

	if host == "" || portStr == "" || username == "" || password == "" || fromAddress == "" {
		return fmt.Errorf("email configuration is incomplete")
	}

	port, err := strconv.Atoi(portStr)
	if err != nil {
		return fmt.Errorf("invalid email port: %v", err)
	}

	// Create the email message
	m := gomail.NewMessage()
	m.SetHeader("From", fromAddress)
	m.SetHeader("To", toEmail)
	m.SetHeader("Subject", fmt.Sprintf("ðŸš¨ VPS Pilot Alert - %s", alert.Metric))

	// HTML email body
	body := fmt.Sprintf(`
	<html>
	<body>
		<h2 style="color: #e74c3c;">ðŸš¨ ALERT ðŸš¨</h2>
		<div style="background-color: #f8f9fa; padding: 20px; border-left: 4px solid #e74c3c;">
			<p><strong>Node:</strong> %s</p>
			<p><strong>IP:</strong> %s</p>
			<p><strong>Metric:</strong> %s</p>
			<p><strong>Current Value:</strong> %s</p>
			<p><strong>Threshold:</strong> %s</p>
			<p><strong>Timestamp:</strong> %s</p>
		</div>
		<p style="color: #6c757d; font-size: 12px;">This alert was generated by VPS Pilot monitoring system.</p>
	</body>
	</html>
	`, alert.NodeName, alert.NodeIp, alert.Metric, alert.CurrentValue, alert.Threshold, alert.Timestamp.Format(time.RFC1123))

	m.SetBody("text/html", body)

	// Create dialer
	d := gomail.NewDialer(host, port, username, password)
	d.TLSConfig = &tls.Config{InsecureSkipVerify: true}

	// Send the email
	if err := d.DialAndSend(m); err != nil {
		return fmt.Errorf("failed to send email: %v", err)
	}

	fmt.Println("Alert sent to email:", toEmail)
	return nil
}

// SendSlackAlert sends alert notifications via Slack webhook
func SendSlackAlert(webhookURL string, alert AlertMsg) error {
	// Format the alert message for Slack
	message := fmt.Sprintf(
		":rotating_light: *ALERT* :rotating_light:\n*Node:* `%s`\n*IP:* `%s`\n*Metric:* *%s*\n*Current Value:* `%s`\n*Threshold:* `%s`\n*Timestamp:* %s",
		alert.NodeName, alert.NodeIp, alert.Metric, alert.CurrentValue, alert.Threshold, alert.Timestamp.Format(time.RFC1123),
	)

	// Prepare the Slack payload
	payload := map[string]interface{}{
		"text": message,
		"attachments": []map[string]interface{}{
			{
				"color": "danger",
				"fields": []map[string]interface{}{
					{
						"title": "Node",
						"value": alert.NodeName,
						"short": true,
					},
					{
						"title": "IP Address",
						"value": alert.NodeIp,
						"short": true,
					},
					{
						"title": "Metric",
						"value": alert.Metric,
						"short": true,
					},
					{
						"title": "Current Value",
						"value": alert.CurrentValue,
						"short": true,
					},
					{
						"title": "Threshold",
						"value": alert.Threshold,
						"short": true,
					},
					{
						"title": "Timestamp",
						"value": alert.Timestamp.Format(time.RFC1123),
						"short": true,
					},
				},
			},
		},
	}

	// Marshal the payload to JSON
	body, err := json.Marshal(payload)
	if err != nil {
		return err
	}

	// Send the POST request to the Slack webhook
	resp, err := http.Post(webhookURL, "application/json", bytes.NewBuffer(body))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Check for successful response
	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		fmt.Println("Alert sent to Slack!")
	} else {
		return fmt.Errorf("failed to send Slack alert, status code: %d", resp.StatusCode)
	}

	return nil
}
